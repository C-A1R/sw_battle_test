# sw_battle_test

## Симуляция битвы юнитов на карте

Дана карта размера H*W клеток, на карте размещается N юнитов. Существуют юниты разного типа с разным действиями и характеристиками. Один юнит занимает одну клетку (координату), в одной клетке не может быть несколько юнитов.

За каждый игровой тик (ход) каждый юнит может выполнить одно действие, независимо от других юнитов. Юниты выполняют свои действия за тик в том порядке, в котором они были созданы.

При запуске в программу подается список команд, по мере исполнения программа выводит
произошедшие события. Симуляция заканчивается, когда нет ни одного юнита с действием на следующий тик.

### Для всех юнитов

* Параметр: Id. Уникальный идентификатор юнита, целое число.
* Характеристика: HP (Health points). Если равна 0, то юнит умирает. В следующем тике его не будет на карте. Юнит совершает свое действие за тик, даже если он умер в этом тике.
* Действие: Move. Юнит идет в заданную точку на карте. В каждый тик юнит может перейти в любую из 8-ми клеток вокруг него по направлению к цели. Если клетка занята, юнит не совершает движения. Поиск пути не нужен: на карте нет статических препятствий.

### Типы юнитов

1. Воин
    * Характеристика: Strength
    * Действие: Melee Attack. Приоритетнее, чем Move. Если в радиусе одной клетки есть другие юниты, то выбирается и атакуется один юнит. Выбирает самого слабого по HP, либо самого младшего по Id и сражается с ним до смерти врага (или своей). За один тик вычитает из HP другого юнита значение, равное его Strength.

1. Лучник
    * Характеристики: Strength, Range и Agility
    * Действие: Melee Attack - такое же, как у Воина.
    * Действие: Range Attack. Приоритетнее, чем Move и Melee Attack. Если в радиусе от 2х клеток (включительно) до Range (включительно) есть другие юниты, то выбирает и атакует юнита. Выбирает ближайшего, либо самого слабого по HP, либо самого младшего по Id, сражается с ним до смерти врага (или своей). За один тик вычитает из HP другого юнита значение равное его Agility.

### Команды

При запуске приложение получает в argv путь к файлу со сценарием работы, в котором описаны команды. Существуют следующие команды: CREATE_MAP, SPAWN_WARRIOR, SPAWN_ARCHER, MARCH и WAIT.

#### Пример сценария

Формат: COMMAND_NAME arg1 arg2 ...\
Для каждой команды в заданной позиции аргументов находится конкретное свойство

// Cоздать карту widht=10 height=10 (может быть только одна и в самом начале)\
CREATE_MAP 10 10

// Разместить воина id=1 в точке x=0 y=0 с hp=10 и strength=2\
SPAWN_WARRIOR 1 0 0 10 2

// Разместить лучника id=2 в точке x=9 y=0 с hp=10, strength=2, range=2, agility=3\
SPAWN_ARCHER 2 9 0 5 1 5 2

// Отправить юнит id=1 в точку 9 0\
MARCH 1 9 0

// Отправить юнит id=2 в точку 0 0\
MARCH 2 0 0

// Подождать 10 тиков прежде чем выполнять следующие команды\
WAIT 10

// Разместить воина id=3 в точке x=9 y=9 с hp=10 и strength=2\
SPAWN_WARRIOR 3 9 9 10 2

// Отправить юнит id=3 в точку х=0 y=0\
MARCH 3 0 0

### События

Программа выводит все происходящие события в stdout. Существуют следующие события: MAP_CREATED, UNIT_SPAWNED, MARCH_STARTED, UNIT_MOVED, UNIT_ATTACKED, MARCH_ENDED, UNIT_DIED.

#### Пример вывода

Формат: [TICK_NUMBER] EVENT_NAME field1=value field2=value...

[1] MAP_CREATED width=10 height=10\
[1] UNIT_SPAWNED unitId=1 unitType=Archer x=5 y=3\
[1] UNIT_SPAWNED unitId=2 unitType=Warrior x=5 y=3\
[1] MARCH_STARTED unitId=1 x=5 y=3 targetX=7 targetY=9\
[2] UNIT_MOVED unitId=1 x=6 y=4\
[3] UNIT_ATTACKED attackerUnitId=1 targetUnitId=2 damage=5 targetHp=0\
[4] MARCH_ENDED unitId=1 x=7 y=9\
[5] UNIT_DIED unitId=1

## todo

* проверка на уникальные id
* проверка на отрицательные координнаты
* тесты

## По тестовому возникли такие моменты от коллег

* [fixed] Реализация всех команд лежит в классе Battle еще и в хидере - непонятно почему нельзя было реализацию хотя бы в cpp унести + отдельный класс

* [fixed] Не поняли зачем тут понадобился темплейт. Такой код не сломается при компиляции, если появится новый тип команды, а значит разработчик забудет его поддержать

    ```c++
    template<typename TCommand> void addCommand(TCommand &&cmd) { }
    template<> void addCommand(io::CreateMap &&cmd)
    ```

* [fixed] В классе Battle лежит логика по убийству юнитов и атаке, хотя он вроде как должен только тики прокручивать

* [fixed] Использует туплы вместо отдельной читаемой структуры

    ```c++
    std::tuple<uint32_t, uint32_t, uint32_t> t;
    uint32_t tId {0};
    uint32_t dam {0};
    uint32_t tHp {0};
    std::tie(tId, dam, tHp) = t;
    ```

* Использует unitId = 0 как признак того, что в точке на карте никого нет. Семантически такое решение не говорит другому разработчику, что тут юнита может не быть и что надо не забыть проверить на 0

    ```c++
    _model[it->second.x][it->second.y] = 0
    ```
